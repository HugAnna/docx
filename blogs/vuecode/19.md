---
title: 19：实现component
date: 2024-03-07  
tags:
 - vue核心源码
categories:
 - vue核心源码
sidebar: 'auto'
---  
### 为什么使用组件开发?  
1. 降低了开发粒度,从而降低了整体复杂度
2. 减少重复代码(复用),提升了开发效率和可维护性  
3. 利于团队开发,性能更好  

**组件的结构**  
属性,样式,插槽  

``` js
// 全局组件：任何Vue实例中使用。  
Vue.component('my-button', {
    template:`<button>按钮</button>`
})

// 局部组件:只能在当前组件的内部使用。
let vm = new Vue({
  el: '#app',
  data(){return {...}},
  components: {
    'my-button': `<button>内部按钮</button>`
  }
})
``` 
  

**global-api**  
在Vue.component中接收两个参数,id:组件的唯一标识,definition:组件的配置项。
1. 通过Vue.extend利用传入的definition生成Vue子类  
2. 再将Vue子类放到全局Vue.options.components中  
``` js
export function initGlobalApi (Vue) {
  Vue.options = {};
  // 最终会合并到实例上，可以通过vm.$options._base直接使用
  Vue.options._base = Vue;
  // 定义全局组件
  Vue.options.components = {};
  initExtend(Vue);
  Vue.mixin = function (mixin) {
    this.options = mergeOptions(this.options, mixin);
  };
  // 通过Vue.components来注册全局组件
  Vue.components = function (id, definition) {
    const name = definition.name = definition.name || id;
    // 通过Vue.extend来创建Vue的子类
    definition = this.options._base.extend(definition);
    // 将Vue子类添加到Vue.options.components对象中，key为name
    this.options.components[name] = definition;
  };
}
```
**extend**  
Vue.extend利用JS的原型链实现继承，我们会将Vue.prototype指向Sub.prototype._proto_，这样就可以在Sub的实例上调用Vue原型上定义的方法了  
``` js
Vue.extend = function (extendOptions) {
  const Super = this;
  const Sub = function VueComponent () {
    // 会根据原型链进行查找，找到Super.prototype.init方法
    this._init();
  };
  Sub.cid = cid++;
  // Object.create将Sub.prototype的原型指向了Super.prototype
  Sub.prototype = Object.create(Super.prototype);
  // 此时prototype为一个对象，会失去原来的值
  Sub.prototype.constructor = Sub;
  Sub.options = mergeOptions(Super.options, extendOptions);
  Sub.component = Super.component;
  return Sub;
};
```
## **组件渲染流程**  
在用户执行new Vue创建组件的时候，会执行this._init方法。在该方法中，会将用户传入的配置项和Vue.options中定义的配置项进行合并，最终放到vm.$options中  
``` js
function initMixin (Vue) {
  Vue.prototype._init = function (options = {}) {
    const vm = this;
    // 组件选项和Vue.options或者 Sub.options进行合并
    vm.$options = mergeOptions(vm.constructor.options, options);
    // ...  
  };
  // ...  
} 
```  
在mergeOptions中，我们为strategies添加合并components的策略。   
components的合并利用了JavaScript的原型链，将Vue.options.components中的全局组件放到了合并后对象的原型上。     
而将options中components 属性定义的局部组件放到了自身的属性上。这样当取值时，首先会从自身属性上查找，然后再到原型链上查找，也就是优先渲染局部组件，如果没有局部组件就会去渲染全局组件。  
``` js
strategies.components = function (parentVal, childVal) {
  const result = Object.create(parentVal); // 合并后的原型链为parentVal
  for (const key in childVal) { // childVal中的值都设置为自身私有属性，会优先获取
    if (childVal.hasOwnProperty(key)) {
      result[key] = childVal[key];
    }
  }
  return result;
};
```  
**创建虚拟节点**  
虚拟节点中做了哪些事?    
1. 通过vm.$options拿到合并后的components
2. 用Vue.extend将components中的对象转换为Vue子类构造函数
3. 在虚拟节点上的props上添加钩子函数，方便在之后调用
4. 执行vNode函数创建组件虚拟节点，组件虚拟节点会新增componentOptions属性来存放组件的一些选项
createVElement中，如果tag不是html中定义的标签，便需要创建组件对应的虚拟节点。 

``` js
function createVComponent (vm, tag, props, key, children) {
  const baseCtor = vm.$options._base;
  // 在生成父虚拟节点的过程中，遇到了子组件的自定义标签。它的定义放到了父组件的components中，所有通过父组件的$options来进行获取
  // 这里包括全局组件和自定义组件，内部通过原型链进行了合并
  let Ctor = vm.$options.components[tag];
  // 全局组件：Vue子类构造函数，局部组件：对象，合并后的components中既有对象又有构造函数，这里要利用Vue.extend统一处理为构造函数
  if (typeof Ctor === 'object') {
    Ctor = baseCtor.extend(Ctor);
  }
  props.hook = { // 在渲染真实节点时会调用init钩子函数
    init (vNode) {
      const child = vNode.componentInstance = new Ctor();
      child.$mount();
    }
  };
  return vNode(`vue-component-${Ctor.id}-${tag}`, props, key, undefined, undefined, { Ctor, children });
}

function createVElement (tag, props = {}, ...children) {
  const vm = this;
  const { key } = props;
  delete props.key;
  if (isReservedTag(tag)) { // 是否为html的原生标签
    return vNode(tag, props, key, children);
  } else {
    // 创建组件虚拟节点
    return createVComponent(vm, tag, props, key, children);
  }
}
```
**创建真实节点**  
在处理虚拟节点时，我们会获取到在创建组件虚拟节点时为props添加的init钩子函数，将vNode传入执行init函数,通过new Ctor()来进行子组件的初始化工作。  
Ctor是通过Vue.extend来生成的，而在执行Vue.extend的时候，我们已经将组件对应的配置项传入。但是由于配置项中缺少el选项，所以要手动执行$mount方法来挂载组件。  
在执行$mount之后，会将组件template创建为真实DOM并设置到vm.$el选项上。执行props.hook.init方法时，将组件实例放到了vNode的componentInstance 属性上。  
最终在createComponent中会判断，如果有该属性则为组件虚拟节点。并将其对应的dom(vNode.componentInstance.$el)返回，最终挂载到父节点上，渲染到页面中。
``` js 
// 处理组件虚拟节点
function createComponent (vNode) {
  let init = vNode.props?.hook?.init;
  init?.(vNode);
  if (vNode.componentInstance) {
    return true;
  }
}

// 将虚拟节点处理为真实节点
function createElement (vNode) {
  if (typeof vNode.tag === 'string') {
    if (createComponent(vNode)) {
      return vNode.componentInstance.$el;
    }
    vNode.el = document.createElement(vNode.tag);
    updateProperties(vNode);
    for (let i = 0; i < vNode.children.length; i++) {
      const child = vNode.children[i];
      vNode.el.appendChild(createElement(child));
    }
  } else {
    vNode.el = document.createTextNode(vNode.text);
  }
  return vNode.el;
}
```

**面试题**  
1. 全局组件和局部组件一样时，会渲染哪个?  
局部组件。全局组件和局部组件通过Vue.component方法合并到一起。
components的合并利用了JavaScript的原型链,Vue.options.components中的全局组件放到了合并后对象的原型上，而将options中components 属性定义的局部组件放到了自身的属性上。这样当取值时，首先会从自身属性上查找，然后再到原型链上查找，也就是优先渲染局部组件，如果没有局部组件就会去渲染全局组件。  
2. 父子组件生命周期执行顺序  
  - 首先会初始化父组件，执行父组件的beforeCreate,created钩子。
  - 接下来会挂载父组件，在挂载之前会先执行beforeMount钩子。
  - 当父组件开始挂载时，首先会生成组件虚拟节点，之后在创建真实及节点时，要new SubComponent来创建子组件，得到子组件挂载后的真实  DOM:vm.$el。
  - 而在实例化子组件的过程中，会执行子组件的beforeCreate,created,beforeMount,mounted钩子
  - 在子组件挂载完毕后，继续完成父组件的挂载，执行父组件的mounted钩子。





