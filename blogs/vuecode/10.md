---
title: 10：创建Watcher类实现更新
date: 2024-03-02 
tags:
 - Vue核心源码
categories:
 - Vue核心源码
sidebar: 'auto'
---
index.html中,修改在data中的数据,数据并不会更新。因为数据改变了之后并没有调用重新渲染的方法，但是又不能每次数据改变去手动调用渲染的方法。vue源码中是使用watcher来实现自动更新视图。  

```  js
        let vm = new Vue({
            el: '#app', //挂载元素
            data() {
                return {
                     arr:[{a:1}],
                     name:'小明',
                     msg:'hello'
                }
            },
            //
            created(){ // 生命周期就是一个，函数的调用，现在vue中定阅号， 后续会触发此方法

            }
      
        })
       

        setTimeout(() => {
           vm.msg = '张三' //如果更新数据 watcher.updata() 方法
        //    vm._updata(vm._render())  //重新封装成一个渲染 watcher
        }, 1000);
        //问题：我不可能让用户修改数据  执行vm._updata() 这个方法
        //vue 方法
        //数据变化，自动更新视图（就是调用 vm._updata(vm._render())）就可以了
        //注意：vue更新组件策略是以组件为单位的，给每个组件都增加watcher,属性变化后会
        //调用这个watcher(渲染watcher)
```  
在生命周期渲染前后，调用Watcher实例方法，并传入4个参数。1.vm实例 2.渲染方法 3.更新逻辑 4.渲染标识,来实现更新。Watcher中不仅能调用渲染的方法,后面还将在其中扩展更多的功能。    

``` js
import Watcher from './observe/watcher'
export function  mountComponent(vm,el){
   //调用render方法去渲染 el属性

   //方法：先调用render方法创建虚拟节点，在将虚拟节点渲染到页面上
   //源码方式
   callHook(vm,"beforeMount")
   //挂载  重新封装一下 变成一个类，这个类他是响应式变的，数据改变了我们就调用这个方法
   //   vm._updata(vm._render()) 
   let updataComponent = ()=>{
      vm._updata(vm._render())
   }
   //这个watcher 是用于渲染的 目前没有任何功能 ，updataComponent 
    new Watcher(vm,updataComponent,()=>{},true) //Watcher 有什么用  和之前差不多，1把实例缠绕进去 ,2在给他传入一个方法
    //true 标识渲染的  ，（）=》{} 跟新逻辑
    callHook(vm,"mounted")
}
```  
在Watcher中,将参数放到实例上,并执行渲染页面的方法
``` js
class Watcher {
    //vm 实例
    //exprOrfn:vm._updata(vm._render()) 
    constructor(vm, exprOrfn, cb, options) {
        // 创建类将选项放在实例上
        this.vm = vm;
        this.exprOrfn = exprOrfn;
        this.cb = cb;
        this.options = options;

        if (typeof exprOrfn === 'function') {
            this.getter = exprOrfn
        }
        // 更新视图
        this.get()
    }   
    // 初次渲染
    get() {
        this.getter()// 渲染页面  render()  
    }
    // 更新
     updata(){
        this.get() //重新渲染
    }
 
}
```



