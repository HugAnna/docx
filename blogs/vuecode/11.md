---
title: 11：实现Dep
date: 2024-03-02 
tags:
 - Vue核心源码
categories:
 - Vue核心源码
sidebar: 'auto'
---
**dep的两个作用:**
1. 在get中收集依赖,并且和data中的属性是一一对应的   
2. 通过notify通知watcher更新。watcher负责订阅/收集当前dep。watcher视图上有几个,就有几个watcher。  

**真正的数据更新顺序**  
配置data的响应式 => 实例化对应依赖的watcher => 触发get => 由Dep去收集相关的watcher =>watcher收集当前的Dep => 页面交互 => 触发set => Dep通知watcher更新 => watcher更新依赖项。  

**官方流程图**  
data和watcher中间少了一个Dep，图中的Notify和Collect as Despendency都是由Dep实例做的。  
![image.png](/vuecode/dep-watcher.png)  

**Dep类**  
定义收集依赖和通知更新的方法。
``` js
//添加id,方便不同的依赖
let id = 0
class Dep {
    constructor() {
        this.subs = []
        this.id = id++
    }
    //收集watcher 
    depend() {
          this.subs.push(watcher)
    }
  
    //通知观察者更新
    notify() {
        this.subs.forEach(watcher => {
            watcher.updata()
        })
    }
}

Dep.targer = null;
export function pushTarget(watcher) {  //添加 watcher
    Dep.targer = watcher //保留watcher
}
export function popTarget() {
    Dep.targer = null //将变量删除
}
export default Dep

```  
**Watcher类**

使用id来标识watcher的唯一,渲染页面前在dep中添加watcher，渲染完成后删除watcher。
``` js{23-25}
import { pushTarget, popTarget } from "./dep";
let id = 0; //全局的
class Watcher {
    //vm 实例
    //exprOrfn vm._updata(vm._render()) 
    constructor(vm, exprOrfn, cb, options) {
        // 1.创建类第一步将选项放在实例上
        this.vm = vm;
        this.exprOrfn = exprOrfn;
        this.cb = cb;
        this.options = options;
        // 2. 每一组件只有一个watcher 他是为标识
        this.id  = id++
        if (typeof exprOrfn === 'function') {
            this.getter = exprOrfn
        }
        // 执行渲染页面
        this.get()
      
    }   

    get() {
        pushTarget(this) // 当前的实例添加watcher
        this.getter() // 渲染页面 执行get()
        popTarget(); //删除当前的实例 这两个方法放在 dep 中
    }
  
    updata(){
        this.get() //重新渲染
    }
}
```  
**defineReactive**  
获取响应式数据时进行依赖收集,数据改变时,调用Dep.notify通知watcher更新
``` js {11,21}
import Dep from './dep';
//对数据进行劫持
function defineReactive(data, key, value) {
    //1给我们的每个属性添加一个dep
    let dep = new Dep();
    //2将dep 存放起来，当页面取值时，说明这个值用来渲染，在将这个watcher和这个属性对应起来
    Object.defineProperty(data, key, {
        get() { 
            //依赖收集
            if(Dep.targer){ //让这个属性记住这个watcher
                dep.depend()
            }
            return value
        },
        set(newValue) { //依赖更新
            //注意设置的值和原来的值是一样的
            // console.log('设置值', data, key, value)
            if (newValue == value) return;
            Observer(newValue) //如果用户将值改为对象继续监控
            value = newValue
            dep.notify() // 通知更新
        }
    })
}
```






