---
title: 14：列队处理
date: 2024-03-03 
tags:
 - vue核心源码
categories:
 - vue核心源码
sidebar: 'auto'
---
当我们在多次更新数据时,每次都要去重新渲染页面，但我们只需要渲染一次。vue中是通过异步来批量处理的。数据更新时，并不会马上执行，等到数据最后更新才会执行。  
**index.html**
``` js
        setTimeout(() => { //nextTick 
            //注意数据更新多次 ，vm._updata(vm._render()) 只需要执行一次
            //批量处理=》vue 异步 数据更新后，不会马上执行
           vm.arr.push(6)
           vm.arr.push(5)
           vm.msg = '张三' //如果更新数据 watcher.updata() 方法
   
        }, 1000);
```
**Watcher类**  
在update中，通过queueWatcher方法来进行列队处理。因为每个组件都是同一个watcher，所以首先要进行去重，再将watcher添加队列。使用防抖（避免多次触发），依次调用队列中run方法来渲染。  
``` js
class Watcher {
    constructor(...){
    ...
    }
    ...
      run() {
        this.get()
    }
    updata() { //三次
        //注意：不要数据更新后每次都调用 get 方法 ，get 方法回重新渲染
        //缓存
        // this.get() //重新渲染
        queueWatcher(this)
    }
}
let queue = [] // 将需要批量更新的watcher 存放到一个列队中
let has = {}
let pending = false
function queueWatcher(watcher) {
    let id = watcher.id // 每个组件都是同一个 watcher
    //  console.log(id) //去重
    if (has[id] == null) {//去重
        //列队处理
        queue.push(watcher)//将wacher 添加到列队中
        has[id] = true
        //防抖 ：用户触发多次，只触发一个
        if (!pending) {
            //异步：等待同步代码执行完毕之后，再执行
             setTimeout(()=>{
               queue.forEach(item=>item.run())
               queue = []
               has = {}
               pending = false
             },0)

        }
        pending = true
    }
}  
```
