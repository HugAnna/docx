---
title: 5：ast语法树变为render函数
date: 2024-02-28
tags:
 - Vue核心源码
categories:
 - Vue核心源码
sidebar: 'auto'
---

**代码入口**
``` js
export function compileToFunction(el) {
   //1 将html 变成ast 语法树
    let ast = parseHTML(el)
    console.log(ast)
    //2 ast 语法树变成 render 函数  （1） ast 语法树变成 字符串  （2）字符串变成函数 
    let code = generate(ast) // _c _v _s
    //3 将render 字符串变成 函数
    let render = new Function(`with(this){return ${code}}`)
    console.log(render)
    
}

```
### 1.ast语法树变成render字符串

``` js
    简单来说就是将ast格式 {tag:'div,attrs:[{id:'#app'}],
    children:[{tag:null,text:hello}]} 
    转为字符串 `_c('${ast.tag}',${ast.attrs.length ? `${genProps(ast.attrs)}`:'undefined' }
    ${children ? `,${children}` : ''})`格式
```  
源码中是通过generate方法来实现,genProps方法用于处理style中多个属性的情况。_c方法解析标签,_v方法表示文本,_s方法解析变量。


**主要代码**
```
const defaultTagRE = /\{\{((?:.|\r?\n)+?)\}\}/g // 匹配{{}}
function genProps(attrs) {
    //处理属性
    let str = ''
    for (let i = 0; i < attrs.length; i++) {
        let attr = attrs[i]
        //注意;   style："color:red;font-size: 20px
        if (attr.name === 'style') {
            let obj = {} //对样式进行特殊处理
            attr.value.split(';').forEach(item => {
                let [key, value] = item.split(':')
                obj[key] = value
            })
            attr.value = obj //
        }
        //拼接  
        str += `${attr.name}:${JSON.stringify(attr.value)},`
    }
    return `{${str.slice(0, -1)}}`  
}

function genChildren(el){
    const children = el.children
    if(children){ 
        return  children.map(child=>gen(child)).join(',') //{}
    }
}
function gen(node){ 
   if(node.type===1){
            //递归
           return generate(node) 
   }else{
       let text = node.text
        if (!defaultTagRE.test(text)) {
            return `_v(${JSON.stringify(text)})`  // _v(html)  _v('hello'+_s(name))
        }
       //处理特殊的文本
        let tokens = [] //存放每一段的代码  _v('hello',+_s(msg))
        //通过一个正则的案例来演示  在浏览器中 let reg = /a/g   reg.test('ab') reg.lastIndex = 0
      
        let lastIndex = defaultTagRE.lastIndex = 0;//如果正则是全局模式 需要每次使用前变为0
        let match;/
       while (match = defaultTagRE.exec(text)) {
           let index = match.index;
            if (index > lastIndex) {
               tokens.push(JSON.stringify(text.slice(lastIndex,index))) 
            //    console.log(tokens)
            }
            //添加插值表达式 {{}}
            tokens.push(`_s(${match[1].trim()})`)
             lastIndex = index+match[0].length 
        }
       //判断还有没有 文本 hello {{msg}}  
        if(lastIndex<text.length){
           tokens.push(JSON.stringify(text.slice(lastIndex))) 
        }
        //最终返回出去
        return `_v(${tokens.join("+")})`
   }
}
//语法层面的转移  处理开始的元素
export function generate(el) {
    console.log(el)
    let children = genChildren(el)
    //方法 拼接字符串  源码也是这样操作 [{}]    ${el.attrs.length?`{style:{color:red}}`:'undefined'}
    let code = `_c('${el.tag}',${el.attrs.length ? `${genProps(el.attrs)}` : 'undefined'}${
        children ? `,${children}` : ''
        })`
    return code
}
```

###  2.render字符串变成函数  
``` js
let render = new Function(`with(this){return ${code}}`)
console.log(render)
```
面试题:_s如何拿到变量?将this传入with,扩展一个作用域





