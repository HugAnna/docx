---
title: 12：实现dep和watcher多对多
date: 2024-03-03 
tags:
 - vue核心源码
categories:
 - vue核心源码
sidebar: 'auto'
---
dep和watcher实际关系是多对多,基于computed实现缓存。    
**Dep类**  
dep中添加id，用于记录不同的dep。depend中双向记忆，互相存放。将dep传入Watcher的addDep方法中,互相存放。 
``` js{10}
let id = 0
class Dep {
    constructor() {
        this.subs = []
        this.id = id++
    }
    //收集watcher 
    depend() {
        //实现双休记忆的，让watcher 记住
        Dep.targer.addDep(this) 
    }
    addSub(watcher){
        this.subs.push(watcher)
    }
    //更新
    notify() {
        // console.log(Dep.targer)
        this.subs.forEach(watcher => {
            watcher.updata()
        })
    }
}

Dep.targer = null;
export function pushTarget(watcher) {  //添加 watcher

    Dep.targer = watcher //保留watcher
    // console.log(Dep.targer)
}
export function popTarget() {
    Dep.targer = null //将变量删除
}
export default Dep
 //多对多的关系
 //1. 一个属性有一个dep ,dep 作用：用来收集watcher的
 //2. dep和watcher 关系：(1)dep 可以存放多个watcher  (2):一个watcher可以对应多个dep
```  
**Watcher类**  
定义deps存放dep,depsId设置为Set类型防止重复。addDep中判断是否存在，不存在，则将dep放入，并调用dep.addSub方法存放watcher。
``` js{30-34}
import { pushTarget, popTarget } from "./dep";

//为什么封装成一个类 ，方便我们的扩展
let id = 0; //全局的
class Watcher {
    //vm 实例
    //exprOrfn vm._updata(vm._render()) 
    constructor(vm, exprOrfn, cb, options) {
        // 1.创建类第一步将选项放在实例上
        this.vm = vm;
        this.exprOrfn = exprOrfn;
        this.cb = cb;
        this.options = options;

        // 2. 每一组件只有一个watcher 他是为标识
        this.id  = id++
        // 3.判断表达式是不是一个函数
        this.deps = []  //watcher 记录有多少dep 依赖
        this.depsId = new Set()
        if (typeof exprOrfn === 'function') {
            this.getter = exprOrfn
        }
        // 4.执行渲染页面
        this.get()
      
    }   
    addDep(dep){
        //去重  判断一下 如果dep 相同我们是不用去处理的
        let id = dep.id
        if(!this.depsId.has(id)){
            this.deps.push(dep)
            this.depsId.add(id)
            //同时将watcher 放到 dep中
            dep.addSub(this)
        }
        // 现在只需要记住  一个watcher 有多个dep,一个dep 有多个watcher
        //为后面的 component 
    }
    get() {
        pushTarget(this) //当前的实例添加
        this.getter()// 渲染页面  render()   with(wm){_v(msg,_s(name))} ，取值（执行get这个方法） 走劫持方法
        popTarget(); //删除当前的实例 这两个方法放在 dep 中
    }

    updata(){
        this.get() //重新渲染
    }
}

export default Watcher
```


