---
title: 3：initData中对数据进行劫持
date: 2024-02-22
tags:
 - vue核心源码
categories:
 - vue核心源码
sidebar: 'auto'
---

### 1.初始化data中的数据

``` js
import {observe} from './observer/index.js'
function initData(vm){
    let data = vm.$options.data;
    data = vm._data = typeof data === 'function' ? data.call(vm) : data;
    observe(data); //为数据添加观测
}
``` 


### 2.对对象中的属性进行递归劫持

**Object.defineProperty**
``` js
function defineReactive(data, key, value) {  //{a:{b:1}}
    observer(value) //深度代理 
    Object.defineProperty(data, key, {
        get() {
            // console.log('获取')
            return value
        },
        set(newValue) {
            // console.log('设置')
            if (newValue == value) return;
            observer(newValue) //如果用户设置的值是对象
            value = newValue
        }
    })
}
export function observe(data) {
    if(typeof data !== 'object' || data == null){
        return;
    }
    return new Observer(data);
}
```
### 3.对数组进行劫持

重写数组原型方法

``` js
let oldArrayProtoMethods = Array.prototype;// 获取数组原型上的方法
export let arrayMethods = Object.create(oldArrayProtoMethods); // 继承数组方法
let methods = [
    'push',
    'pop',
    'shift',
    'unshift',
    'reverse',
    'sort',
    'splice'
];
methods.forEach(method => {
    arrayMethods[method] = function (...args) {
        const result = oldArrayProtoMethods[method].apply(this, args);
        const ob = this.__ob__;
        let inserted;
        switch (method) {
            case 'push':
            case 'unshift':
                inserted = args;
                break;
            case 'splice':
                inserted = args.slice(2) // 截取splice添加的数据
            default:
                break;
        }
        if (inserted) ob.observeArray(inserted); // 对新增的每一项进行观测
        return result
    }
})
```

判断是否为数组并劫持

``` js
import {arrayMethods} from './array';
class Observer { // 观测值
    constructor(value){
        if(Array.isArray(value)){
            value.__proto__ = arrayMethods; // 重写数组原型方法
            this.observeArray(value);
        }else{
            this.walk(value);
        }
    }
    observeArray(value){
        for(let i = 0 ; i < value.length ;i ++){
            observe(value[i]);
        }
    }
}
```


### 4.数据代理

将data中的数据代理到实例vm(this)上,方便访问和修改

**增加__ob__属性**
将Observer添加到__ob__属性上
``` js
class Observer { 
    constructor(value){
        Object.defineProperty(value,'__ob__',{
            enumerable:false,  // 不枚举
            configurable:false, // 不能删除/修改属性
            value:this
        });
        // ...
    }
 }
```

> 给所有响应式数据增加标识，并且可以在响应式上获取`Observer`实例上的方法

``` js
function proxy(vm,source,key){
    Object.defineProperty(vm,key,{
        get(){
            return vm[source][key];
        },
        set(newValue){
            vm[source][key] = newValue;
        }
    });
}
function initData(vm){
    let data = vm.$options.data;
    data = vm._data = typeof data === 'function' ? data.call(vm) : data;
    for(let key in data){ // 将_data上的属性全部代理给vm实例
        proxy(vm,'_data',key)
    }
    observe(data);
}
```

### 劫持主要代码


``` js
import {ArrayMethods} from './arr'

class Observer {
    constructor(value) {
        // 设置属性 
        Object.defineProperty(value,"__ob__",{
                 enumerable:false,  // 不枚举
            configurable:false, // 不能删除/修改属性
            value:this
        })
         // 判断数据
         if(Array.isArray(value)){ //  list:[1,2,3]
            value.__proto__ = ArrayMethods 
            // console.log('数组')
            //如果你是数组对象
             this.observeArray(value) // 处理数组对象 [{a:1}]
         }else{
            this.walk(value)  //遍历
         }
        
    }
    walk(data) { //  {  msg:'hello'，a}
        let keys = Object.keys(data)
        for (let i = 0; i < keys.length; i++) {
            // 对象的每个属性进行劫持
            let key = keys[i] //
            let value = data[key]
            defineReactive(data, key, value)
        }
    }
    observeArray(value){ //[{a:1}] 
         for(let i = 0 ;i<value.length;i++){
            observer(value[i])
         }
    }
}

function defineReactive(data, key, value) {  //{a:{b:1}}
    observer(value) //深度代理
    Object.defineProperty(data, key, {
        get() {
            // console.log('获取')
            return value
        },
        set(newValue) {
            // console.log('设置')
            if (newValue == value) return;
            observer(newValue) //如果用户设置的值是对象
            value = newValue
        }
    })
}
export function observe(data) {
    if(typeof data !== 'object' || data == null){
        return;
    }
    return new Observer(data);
}
```





