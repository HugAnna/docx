---
title: 15：实现nextTick
date: 2024-03-03 
tags:
 - vue核心源码
categories:
 - vue核心源码
sidebar: 'auto'
---
**nextTick原理**  
数据更新完后,获取最新的dom。DOM更新是同步任务，而nextTIck是异步所以能拿到最新的dom。  
**初始化nextTick**  
初始化Vue时调用stateMixin方法，在vm实例上挂载$nextTick。  
![image.png](/vuecode/init_nextTick.png)  

**nextTick实现**  
timerFunc()异步方法,用于处理兼容性问题。MutationObserver是H5的异步方法，可以监听dom变化，监控完毕之后再来异步更新，通过observe方法观测完我们所创建的文本节点变化，从而触发异步方法。setImmediate是ie所支持的定时器。
```
 let callback = []
 let pending = false
 function flush(){
    callback.forEach(cb =>cb())
    pending =false
 }
 let timerFunc
 //处理兼容问题
 if(Promise){
    timerFunc = ()=>{
        Promise.resolve().then(flush) //异步处理
    }
 }else if(MutationObserver){ //h5 异步方法 他可以监听 DOM 变化 ，监控完毕之后在来异步更新
   let observe = new MutationObserver(flush)
   let textNode = document.createTextNode(1) //创建文本
   observe.observe(textNode,{characterData:true}) //观测文本的内容
   timerFunc = ()=>{
    textNode.textContent = 2
   }
 }else if(setImmediate){ //ie
    timerFunc = ()=>{
        setImmediate(flush) 
    }
 }else {
    timerFunc = () => { setTimeout(flush, 0) }
 }
 export function nextTick(cb){
     //列队 [cb1,cb2]
     callback.push(cb)
     //Promise.then()  vue3
     if(!pending){
         timerFunc()   //这个方法就是异步方法 但是 处理兼容问题
         pending = true
     }
 }
```
**优化watcher中列队处理**  
使用nextTick来优化watcher中的队列处理。
```
class Watcher {
        ...
        updata() { //三次
        //注意：不要数据更新后每次都调用 get 方法 ，get 方法回重新渲染
        // this.get() //重新渲染
        queueWatcher(this)
    }
}
let queue = [] // 将需要批量更新的watcher 存放到一个列队中
let has = {}
let pending = false
function flushWatcher() {
    queue.forEach(item => {item.run(),item.cb()}) //cb:回调
    queue = []
    has = {}
    pending = false
}
function queueWatcher(watcher) {
    let id = watcher.id // 每个组件都是同一个 watcher
    //    console.log(id) //去重
    if (has[id] == null) {//去重
        //列队处理
        queue.push(watcher)//将wacher 添加到列队中
        has[id] = true
        //防抖 ：用户触发多次，只触发一个
        if (!pending) {
            //异步：等待同步代码执行完毕之后，再执行
            // setTimeout(()=>{
            //   queue.forEach(item=>item.run())
            //   queue = []
            //   has = {}
            //   pending = false
            // },0)
            nextTick(flushWatcher) //  nextTick相当于定时器
        }
        pending = true
    }
}  
```
**nextTick在vue中的使用** 
1. 当一个 Data 更新时，会执行以下步骤
    1. 触发 Data.set
    2. 调用 dep.notify
    3. Dep 会遍历所有相关的 Watcher 执行 update 方法
    4. 使用queueWatcher来缓存更新的Watcher，queueWatcher中使用nextTick执行异步处理
2. vm上挂载的nextTick,用户需要获取最新的dom,进行某些操作时调用this.$nextTick(()=>{})
**补充生命周期**  
渲染页面之后,执行updated  
![image.png](/vuecode/update-cb.png)


