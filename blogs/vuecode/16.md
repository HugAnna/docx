---
title: 16：实现watch
date: 2024-03-05 
tags:
 - vue核心源码
categories:
 - vue核心源码
sidebar: 'auto'
---  
**watch基本使用方式**
1. 属性 ：方法(函数)
2. 属性 ：数组
3. 属性 ：对象
4. 属性 ：字符串
``` js
    data(){
        a:111,
        c:{c:{c:100}}
        },
    watch: {
        'a'(newValue,oldValue){
            console.log(newValue,oldValue)
             },
        "a": [
              (newValue, oldValue) => {
                  console.log(newValue)
              },
              (newValue, oldValue) => {
                  console.log(newValue)
              }],
        a:{
             handler(){ //
                 console.log('xxx100')
             },
            immediate:true
             },
              "c.c.c"(newValue,oldValue){
            console.log(newValue,oldValue)
             },
             // a:'aa'
            },
           
            methods:{
                aa(){}
            }
```  
## initState.js
**initWatch()**  
initState文件中,写入初始化watch的方法。首先遍历整个watch,针对不同的属性，watch调用createrWatcher方法来进行格式化处理，exprOrfn为表达式，表示可能是字符串/函数;options是用户配置的属性,比如deep、immediate。其中user属性为true时表示是用户的watcher。  
``` js
import Watcher from './observe/watcher'
function initWatch(vm) {
    //1 获取watch
    let watch = vm.$options.watch
    console.log(watch)
    //2 遍历  { a,b,c}
    for (let key in watch) {
        //2.1获取 他的属性对应的值 （判断)
        let handler = watch[key] //数组 ，对象 ，字符，函数
        if (Array.isArray(handler)) {//数组  []
            hendler.forEach(item=>{
                createrWatcher(vm,key,item) 
            })
        } else {//对象 ，字符，函数
           //3创建一个方法来处理
           createrWatcher(vm,key,handler)
        }
    }
}
//vm.$watch(()=>{return 'a'}) // 返回的值就是  watcher 上的属性 user = false
//格式化处理
function createrWatcher(vm,exprOrfn,handler,options){
   //3.1 处理handler
   if(typeof handler ==='object'){
       options = handler; //用户的配置项目
       handler = handler.handler;//这个是一个函数
   }
   if(typeof handler ==='string'){// 'aa'
       handler = vm[handler] //将实例行的方法作为 handler 方法代理和data 一样
   }
   //其他是 函数
   //watch 最终处理 $watch 这个方法
   return vm.$watch(vm,exprOrfn,handler,options)
}
```
**stateMixin()**  
options中添加user:true,表示用户的watcher。判断是否存在immediate，为true则立即执行handler中的方法，早于created
``` js{12-15}
export f-unction stateMixin(vm) {
    console.log(vm,6666)
    //列队 :1就是vue自己的nextTick  2用户自己的
    vm.prototype.$nextTick = function (cb) { //nextTick: 数据更新之后获取到最新的DOM
        nextTick(cb)
    },
    vm.prototype.$watch =function(Vue,exprOrfn,handler,options={}){ //上面格式化处理
        //   console.log(exprOrfn,handler,options)
          //实现watch 方法 就是new  watcher //渲染走 渲染watcher $watch 走 watcher  user false
         //  watch 核心 watcher
         let watcher = new Watcher(Vue,exprOrfn,handler,{...options,user:true})
         if(options.immediate){
            handler.call(Vue) //如果有这个immediate 立即执行
         }
    }
    
}
```
## Watcher  
如果options中没有user,则将user赋为false。判断表达表达式式，不为函数，表示是watch中用户传入的属性，遍历到最后一层并返回。自调用get方法进行渲染,从而获得初始值。触发更新的run方法中，判断是否是用户的watcher，将cb(handler)指向vm, 并传入新旧值。  
``` js
let id = 0; //全局的
class Watcher {
    //vm 实例
    //exprOrfn vm._updata(vm._render()) 
    constructor(vm, exprOrfn, cb, options) {
        // 1.创建类第一步将选项放在实例上
        this.vm = vm;
        this.exprOrfn = exprOrfn;
        this.cb = cb;
        this.options = options;
        // 2. 每一组件只有一个watcher 他是为标识
        this.id = id++
        this.user = !!options.user
        // 3.判断表达式是不是一个函数
        this.deps = []  //watcher 记录有多少dep 依赖
        this.depsId = new Set()
        if (typeof exprOrfn === 'function') {
            this.getter = exprOrfn
        }else{ //{a,b,c}  字符串 变成函数 
            this.getter =function(){ //属性 c.c.c
              let path = exprOrfn.split('.')
              let obj = vm
              for(let i = 0;i<path.length;i++){
                obj  = obj[path[i]]
              }
              return obj //
            }
        }
        // 4.执行渲染页面
        this.value =  this.get() //保存watch 初始值

    }
    ...
    // 更新
    run() { //old new
       let value =  this.get() //new
       let oldValue = this.value //old
       this.value = value
       //执行 hendler (cb) 这个用户wathcer
       if(this.user){
        this.cb.call(this.vm,value,oldValue)
       }
    }
    get() {
        pushTarget(this) //当前的实例添加
      const value = this.getter()// 渲染页面  render()   with(wm){_v(msg,_s(name))} ，取值（执行get这个方法） 走劫持方法
        popTarget(); //删除当前的实例 这两个方法放在 dep 中
        return value
    }
    ...
}

```