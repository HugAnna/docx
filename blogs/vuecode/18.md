---
title: 18：实现computed
date: 2024-03-06  
tags:
 - vue核心源码
categories:
 - vue核心源码
sidebar: 'auto'
---  
### Vue中computed实现缓存的原理:  
### 一、computed是响应式的  
读取computed时就会触发get，设置的时候会触发set。  
### 二、computed是如何控制缓存?  
某个计算属性C依赖data中的A，如果没有缓存，每次读取c的时候，C都会去读取A，就会触发A的get，多次触发A的get是会很消耗性能的，所以computed必须缓存。  
脏数据标记:dirty，是Watcher中的属性。 
        dirty为true时，读取computed值时重新计算
        dirty为false时，读取computed值时会使用缓存
### 三、依赖的data发生改变，computed是如何更新?
页面P中的计算属性C，依赖于data里的A，computed的更新步骤:  
1. 因为C依赖于A，所以A可以收集到c的watcher  
2. 当A发生改变，会把watcher的dirty设置为true  
3. A还会收集页面P的watcher，A会通知P进行更新，页面P重新读取计算属性C，因为此时的dirty是true，所以此时的计算属性要重新计算  
4. computed更新完之后，会把dirty设置成false，如果依赖的A不发生变化，那么下次就会读取缓存。 

**computed参数**  
computed中有两种参数形式，一种是函数，一种是对象。  
``` js
data(){
    return {
        firstName:'张',
        lastName:'三'
    }
}
// 属性:对象
// 属性:对象
computed:{
    fullName(){
        return this.firstName + this.lastName
    },
    //  fullName:{
    //     get(){
    //         this.firstName + this.lastName
    //     },
    //     set(){
    //         ...
    //     } 
    // },
}
```
**initComputed**  
initComputed方法中,对computed中每个属性都进行代理,并给每个属性都添加watcher,Watcher中传入lazy表示是计算属性,用户不使用,则不调用。 

``` js
import Watcher from './observe/watcher'
    ...
function initComputed(vm) {
    let computed = vm.$options.computed
    // 1.需要一个watcher
    let watcher = vm._computedWatchers = {}
    // 2.将computed属性通过defineProperty进行处理 {a(){},b:{}}
    for (const key in computed) {
        let userDef = computed[key]
        // 获取get
        let getter = typeof userDef === 'function' ? userDef : userDef.get;
        // 3.给每个属性添加watcher
        watcher[key] = new Watcher(vm,getter,()=>{},{lazy:true})//用户不使用,则不调用
        // 代理
        defineComputed(vm,key,userDef) 
    }

}
let sharedPropDefinition = {}
function defineComputed(target,key,userDef) {
    sharedPropDefinition = {
        enumerable: true,//可枚举
        configurable: true,//可获取
        get: () => { },
        set:() =>{}
    }
    if (typeof userDef === 'function') {
        sharedPropDefinition.get = createrComputedGetter(key)
    } else {
        sharedPropDefinition.get = createrComputedGetter(key)
        sharedPropDefinition.set = userDef.set
    }
    Object.defineProperty(target,key,sharedPropDefinition)
}
// 高阶函数
function createrComputedGetter(key) {
    return function () {
        let watcher = this._computedWatchers[key]
        if (watcher) {
            if (watcher.dirty) {
                watcher.evaluate()
            }
            return watcher.value
        }
    }
}
```  
**Watcher类**  
``` js
let id = 0; //全局的
class Watcher {
    //vm 实例
    //exprOrfn vm._updata(vm._render()) 
    constructor(vm, exprOrfn, cb, options) {
             ...
        this.deps = []  //watcher 记录有多少dep 依赖
        // computed
        this.lazy = options.lazy //有lazy说明是computed
        this.dirty = this.lazy  //dirty标识用户是否执行
            ...
        // 4.执行渲染页面,如果是计算属性,则不执行
        this.value = this.lazy?void 0:this.get() //保存watch 初始值
    }
    ...
    get() {
        // Dep.target = watcher
        pushTarget(this) //当前的实例添加
        const value = this.getter() // watcher中传入的表达式
        popTarget(); //删除当前的实例 这两个方法放在 dep 中
        return value
    }
    updata() { 
        //注意：不要数据更新后每次都调用 get 方法 ，get 方法回重新渲染
        //缓存
        // 计算属性
        if (this.lazy) {
            this.dirty = true
        } else {
              // this.get() //重新渲染
            queueWatcher(this) //重新渲染
        }
    }
    evaluate () {
        this.value = this.get()
        this.dirty = false
    }
    depend() {
        // 
        let i = this.deps.length
        while (i--) {
          this.deps[i].depend()
        }
      }
}

```  
**Dep类**
``` js
class Dep {
    constructor(){
        ...
    }
    ...
}
// 处理多个watcher
let stack = []
export function pushTarget(watcher) {  //添加 watcher

    Dep.target = watcher //保留watcher
    // 入栈
    stack.push(watcher)
}
export function popTarget() {
    // Dep.target = null //将变量删除
    // 解析完一个watcher,就删除一个
    stack.pop()
    // 获取到前一个watcher
    Dep.target =stack[stack.length - 1]
}
```
