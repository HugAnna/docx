---
title: 实现Proxy代理
date: 2024-03-20
categories: 
 - Vue3核心
tags:
 - Vue3核心
sidebar: 'auto'
---
文件目录

```
├─packages             
│  └─reactivity
|      └─dist
│      └─ package.json
│      └─src
|          reativeApi.ts
│          index.ts
|          baseHandlers.ts
│  └─shared
│      └─ package.json
│      └─src
│          index.ts
```
## reactivity

index中只导出方法，不实现功能

- index.ts
``` js
export {
    reative,
    shallowReative,
    shallowReadonly,
    readonly
}  from './reativeApi'
 
```

- reativeApi.ts

1. 根据不同的api定义不同的handler，并将handler传入createReativeObject中

2. createReativeObject方法中,判断对象是否存在于映射表中，如果存在，则直接返回，如果不存在，则先通过Proxy代理该对象,再将代理对象和代理结果缓存起来,避免重复代理。


``` js
import { isObject } from "@vue/shared";

//四个api 各子的处理方法
import {
    reativeHandlers,
    shallowReativeHandlers,
    readonlyHandlers,
    shallowReadonlyHandlers
} from './baseHandlers'
export function reative(target) {
 
    return createReativeObject(target, false, reativeHandlers)
}

export function shallowReative(target) {
    return createReativeObject(target, false, shallowReativeHandlers)
}

export function readonly(target) {
    return createReativeObject(target, true, readonlyHandlers)
}

export function shallowReadonly(target) {
    return createReativeObject(target, true, shallowReadonlyHandlers)
}
//这个四个方法 总结一下：是不是只读，是不是深度，
//方法一：定义四各种的方法   方法二通过参数来实现  柯里化：通过参数来处理我们不同的逻辑
// 这四个方法最核心的式  new  Proxy()   对数据的读取和数据的修改 ， get  set
const reativeMap = new WeakMap(); //自动的垃圾回收，不会造成内存泄漏，就是key 只能是对象
const readonlyMap = new WeakMap();
export function createReativeObject(target, isReadonly, baseHandlers) {
    //最重要的逻辑 ：创建  new Proxy
    //注意： reativeApi 都是通过  proxy 进行拦截  target 一定是对象 
    //ref  简单的数据类型
    //（1）判断类型 是不是对象  在shared 添加这个方法
    if (!isObject(target)) {
        return target
    }
    //(2) 如果某个对象已经代理了 就不用再代理 ， 这个对象 被代理的是深度， 或的只读代理
    //方法 创建一个映射表  
    const proxyMap = isReadonly ? readonlyMap : reativeMap
     //判断缓存中是否有这个对象
     const exisitProxy =proxyMap.get(target)
     if(exisitProxy){
         return exisitProxy // 如果已经代理直接返回
     }
    //核心
    const proxy = new Proxy(target, baseHandlers)
    proxyMap.set(target, proxy);// 将要代理的对象和对应代理的结果缓存起来
    return proxy
}
```

- baseHandlers.ts

不同的api传入不同参数；再通过柯里化,返回set和get方法。实现参数复用。

``` js
// 实现 new  Proxy(target,baseHandlers) 里面有 get  set
import { extend } from '@vue/shared'
import { isObject } from '@vue/shared';
import {readonly,reative} from './reativeApi'

function createGetter(isReadonly = false, shallow = false) { //拦截获取的功能
    //返回值是一个函数
    return function get(target, key, receiver) { //let state = reative() state.name
        // proxy + Reflect(反射),vue3是当取值会进行代理， 这种模式叫做懒代理
        const res = Reflect.get(target, key, receiver) //  target[key]
        //是不是只读
         if(!isReadonly){ //不是 只读
             //收集依赖，等数据变化后更新视图
             ...
            }
        //是不是浅的
        if(shallow){ //是浅的
               return res
        }
        //如果这个res 是一个对象  递归
        //vue2 上来就是 递归 
         if(isObject(res)){ //对象  {list:{n:100},name:"张三"}
             return isReadonly? readonly(res):reative(res)
         }
        return res
    }
}
//二set  设置
function createSetter(shallow = false) { //拦截设置的功能
    return function set(target, key, value, receiver) {  //state.name = 100
        const result = shallow ?target[key] = value: Reflect.set(target, key, value, receiver)

        return result
    }
}
const get = createGetter()
const shallowReactiveGet = createGetter(false, true)
const reandonlyGet = createGetter(true)
const shallowReadonlyGet = createGetter(true, true)


const set = createSetter()
const shallowSet = createSetter(true)
export const reativeHandlers = {
    get,
    set
}
export const shallowReativeHandlers = {
    get: shallowReactiveGet,
    set: shallowSet
}
// 进行合拼  
let readonlyObj = {
    set: (target, key) => {
        console.warn(`set ${target} on key ${key} falied`)
    }
}
export const readonlyHandlers = extend({
    get: reandonlyGet,

}, readonlyObj)
export const shallowReadonlyHandlers = extend({
    get: shallowReadonlyGet,

}, readonlyObj)
```
- shared/src/index.ts
``` js
export const isObject =(val)=> typeof val =='object' &&val !==null;

export  const  extend = Object.assign
```