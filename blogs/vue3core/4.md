---
title: 收集依赖
date: 2024-03-21
categories: 
 - Vue3核心
tags:
 - Vue3核心
sidebar: 'auto'
---
effect 作为 reactive 的核心，主要负责收集依赖，更新依赖

## 准备工作

首先在index中,暴露effect

- /reactivity/src/index.js`
``` js
export {
    reative,
    shallowReative,
    shallowReadonly,
    readonly
}  from './reativeApi'
 
export {effect} from './effect'
```
optionations中枚举操作符

- optionations.js
``` js
 //操作符 就是你做什么操作
 export  const enum TrackOptypes {
     GET
 }

```
## 收集依赖

effect函数,一般用于内部使用。

获取代理数据和在视图中获取数据，就会触发get，从而收集effect。也就是说获取数据时，才会收集依赖。

``` html
<script src="./dist/vue.global.js"></script>
<script>
let {reactive,effect} = Vue;
let state = reactive({name:'why',age:18})
    effect(()=>{
        state.name
    }，{lazy:true})

</script>

```
### 创建响应式effect

1. 添加属性 id  和 _iseffect用于区分响应式的effect ，raw(用于保存用户的方法) ，options 再effect
2. 默认执行一次

### 定义track 用于收集effect

- effectStack栈型结构，用于处理effect嵌套问题

- 创建targetMap映射表，处理目标对象中有多个 effect的情况  

  {name:"张三"，age:15} => name => [effect1,effect2]


- effect.js`
``` js
export function effect(fn, options: any = {}) {
    //我们需要这个effect变成响应式的effct，可以做到数据变化重新执行
    const effect = createReactiveEffect(fn, options)
    //(1)响应式的effect默认会先执行一次
    if (!options.lazy) {
        effect()
    }

    return effect;
}


let uid = 0
let activeEffect //存放当前的effect
//创建一个栈
const effectStack = []

function createReactiveEffect(fn, options) {
    //注意：这个方法返回的是一个函数
    const effect = function reactiveEffect() {
        if (!effectStack.includes(effect)) { //保证effect没有加入到effectStack
            try {  //语句用于处理代码中可能出现的错误信息。
                //入栈
                effectStack.push(effect)
                activeEffect = effect
                // console.log('todo.....')   //默认执行 用户的写的方法
                // 这个effect 是有返回结果的
                return fn(); // 函数执行时会取值操作 会执行get 方法的
            } finally {
                //出栈 
                effectStack.pop()
                activeEffect = effectStack[effectStack.length - 1]
            }
        }
    }
    effect.id = uid++; //添加标识，用于区分effect(是谁的)
    effect._isEffect = true;// 这个标识用于区分他是响应式effect
    effect.raw = fn; //保存用户的原函数
    effect.options = options; //再effect上保存用户的选项
    return effect
}
//
//   effect(()=>{},{flush:'sync'})


// 定义track 作用收集effect
// 二 收集effect
// 上面的操作就是让对象中的属性  收集当前他对应的effect函数

// 创建表
let targetMap = new WeakMap()
export function Track(target, type, key) { //可以拿到当前的effect
    activeEffect //当前正在运行的effect
    // console.log(target, key,activeEffect) //获取当前的effect
    // 问题:  weakMmap =>key=  target=> 属性 =》[effect,effect]
    if (activeEffect === undefined) { // 此属性不用收集依赖，因为没有再effect中使用
        return;
    }
    // (1)获取 effect
    let depsMap = targetMap.get(target); //没有  
    if (!depsMap) { //没有 
        targetMap.set(target, (depsMap = new Map)) //第二个参数是不是他的只  map
    }
    //有 target 
    // 有没有key
    let dep = depsMap.get(key)
     if(!dep ){ //没有key
         depsMap.set(key,(dep = new Set))
     }
     //设置  set
     if(!dep.has(activeEffect)){ //没有
           dep.add(activeEffect)
     }
     console.log(targetMap)

}

```

get中对响应式数据,执行Track，收集依赖

- baseHandlers.js`
``` js
import { extend } from '@vue/shared'
import { isObject } from '@vue/shared';
import {readonly,reative} from './reativeApi'
import {TrackOptypes} from './optionations'
import { Track} from './effect'
function createGetter(isReadonly = false, shallow = false) { //拦截获取的功能
    //返回值是一个函数
    return function get(target, key, receiver) { //let state = reative() state.name
        // proxy + Reflect(反射),vue3是当取值会进行代理， 这种模式叫做懒代理
        const res = Reflect.get(target, key, receiver) //  target[key]
        //是不是只读
         if(!isReadonly){ //不是 只读
             //收集依赖，等数据变化后更新视图
             console.log('执行effect时取值 收集effect') 
             //现在vue3是不是很清楚， 我们的响应式数据 使用我们就收集对应的effect,(name,age)
             //收集effect    再源码中
             Track(target,TrackOptypes.GET,key)
            }
        //是不是浅的
        if(shallow){ //是浅的
               return res
        }
        //如果这个res 是一个对象  递归
        //vue2 上来就是 递归 
         if(isObject(res)){ //对象  {list:{n:100},name:"张三"}
             return isReadonly? readonly(res):reative(res)

         }
        return res
    }
}
    ...
```

## 面试题

vue3中的响应式?

reactive通过Proxy代理,懒代理,性能优化。懒代理: 只有当数据被使用的时，才会进行代理，

readonly（只读）通过Proxy代理,只有get

shallowReative只代理第一层

shallowReadonly（只读）只代理第一层

effect收集依赖,,vue2中使用watcher,每个属性对应一个watcher,effect数据被读取才会进行代理,性能优化


