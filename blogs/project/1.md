---
title: 大屏适配
date: 2024-03-18
categories: 
 - 项目
tags:
 - 项目
sidebar: 'auto'
---
## rem 适配
安装px2rem,并文件引入[lib-flexible](https://www.npmjs.com/package/lib-flexible?activeTab=code),方便将px单位转换为rem

``` 
npm install postcss-px2rem px2rem-loader --save
```

设置px->rem的比例

- vue.config.js
``` js
module.exports={
 css: {
    extract: {ignoreOrder: true},//系统默认之前
    loaderOptions: {
      css: {},
      postcss: {
        plugins: [
          require('postcss-px2rem')({
            // 以设计稿750为例， 750 / 10 = 75
            remUnit: 192,
            remPrecision: 8
          }),
        ],
      }
    }
  },
}
```

设置根节点文字大小为可视区域与份数的比值

- lib-flexible.js 

``` js
    function refreshRem(){
        var width = docEl.getBoundingClientRect().width;
        // if (width / dpr > width) {
        //     width = 540 * dpr;
        // }

        var rem = width / 10;
        docEl.style.fontSize = rem + 'px';
        flexible.rem = win.rem = rem;
    }

```
## scale + rem

1. 根据宽高比,改变宽高进行缩放

- AutoScalContainerV2

``` vue
<template>
    <div 
        class="auto-scal-container"
        ref="AutoScalContainerRef">
        <div 
            ref="DomRef" 
            class="auto-scal-container-inner">
            <slot></slot>
        </div>
    </div>
</template>

<script>
import { 
    defineComponent,ref,getCurrentInstance,reactive,toRef, 
    computed,onMounted,onActivated,watch,
    onBeforeUnmount,
} from "vue";

export default defineComponent({
    props:{
        width:{
            type:Number,
            default:1920,
        },
        height:{
            type:Number,
            default:1080,
        },
        /** 内部容器的宽高比例 */
        ratio:{
            type:Number,
            default:1920 / 1080,
        },
        /** 
         * fit，原理同img的object-fit
         * contain : 被替换的内容将被缩放，以在填充元素的内容框时保持其宽高比。
         * cover : 被替换的内容在保持其宽高比的同时填充元素的整个内容框。如果对象的宽高比与内容框不相匹配，该对象将被剪裁以适应内容框。
         *  */
        fit:{
            type:String,
            default:'contain',
        },
    },
    emits:['onResizeScreen'],
    setup(props,{emit}){
        const DomRef = ref(null);  //组件实例
        const AutoScalContainerRef = ref(null);  //组件实例
        const dataContainer = reactive({
            height:toRef(props,'height'),
            width:toRef(props,'width'),
            ratio:toRef(props,'ratio'),
            fit:toRef(props,'fit'),
        });
        /** 是否是文档上 */
        function isActive(){
            if(!DomRef.value) return false;
            return DomRef.value.getRootNode() === document;
        }
        /** 自动缩放 */
        function autoResizeScreen(){
            if(!AutoScalContainerRef.value) return;
            if(!DomRef.value) return;
            if(!isActive) return;
            let rect = AutoScalContainerRef.value.getBoundingClientRect();
            let clientWidth = rect.width;
            let clientHeight = rect.height;
            let width = dataContainer.width;
            let height = dataContainer.height;
            let domWidth = 0;
            let domHeight = 0;
            let domTop = 0;
            let domLeft = 0;
            /** 使用外部传入的比例或者传入的宽高计算比例 */
            let ratio = dataContainer.ratio || (width / height);
            // 获取比例  可视化区域的宽高比与 屏幕的宽高比  来进行对应屏幕的缩放
            if(dataContainer.fit == 'contain'){
                if ((clientWidth / clientHeight) > ratio) {
                    domHeight = clientHeight;
                    domWidth = ratio * domHeight;
                    domTop = 0;
                    domLeft = (clientWidth - domWidth) / 2;
                } else {
                    domWidth = clientWidth;
                    domHeight = domWidth / ratio;
                    domTop = (clientHeight - domHeight) / 2;
                    domLeft = 0;
                }
            }
            if(dataContainer.fit == 'cover'){
                if ((clientWidth / clientHeight) > ratio) {
                    domWidth = clientWidth;
                    domHeight = domWidth / ratio;
                } else {
                    domHeight = clientHeight;
                    domWidth = ratio * domHeight;
                }
            }
            // 防止组件销毁后还执行设置状态s
            Object.assign(DomRef.value.style, {
                width: `${domWidth}px`,
                height: `${domHeight}px`,
                top: `${domTop}px`,
                left: `${domLeft}px`,
            });
            console.log(DomRef.value.style);
            /** 向外部通知已经计算缩放 */
            emit('onResizeScreen',{
                width:domWidth,
                height:domHeight,
            });
        }
        /** 防抖 */
        let timer_1;
        function fnContainer(){
            clearTimeout(timer_1);
            // timer_1 = setTimeout(()=>{
                autoResizeScreen();
            // },16);
        }
        let timer = setInterval(()=>{
            fnContainer();
        },300);
        onMounted(() => {
            autoResizeScreen();
        });
        window.addEventListener('resize', fnContainer);
        onBeforeUnmount(() => {
            window.removeEventListener('resize', fnContainer);
            window.clearInterval(timer);
        });
        return {
            dataContainer,
            DomRef,
            AutoScalContainerRef,
        };
    },
});
</script>

<style lang="scss" scoped>
.auto-scal-container {
    width: 100%;
    height: 100%;
    position: relative;
    display: flex;
    justify-content: flex-start;
    align-items: flex-start;
    overflow: auto;
    /** 隐藏滚动条 */
    -ms-overflow-style: none;
    scrollbar-width: none;
    &::-webkit-scrollbar {
        display: none;
    }
    >.auto-scal-container-inner {
        position: absolute;
        overflow: hidden;
        transform-origin: left top;
        width: 0;
        height: 0;
        top: 0;
        left: 0;
    }
}
</style>

```
具体大屏中使用,handleResizeScreen方法中根据具体缩放比,动态设置文字大小 

``` vue
<script>
/** 
 * 大屏主页面
 * 采用缩放的形式进行适配，搭配rem的话很方便实用
 *  */
import { defineComponent,ref,getCurrentInstance,reactive,toRef, computed,onMounted,onActivated,watch } from "vue";
import AutoScalContainerV2 from "@/components/AutoScalContainerV2.vue";
import {setRem} from "@/common/Rem.js";
import { useRoute } from "vue-router";
export default defineComponent({
    name:'BigScreenView',
    components: {
        AutoScalContainerV2,
    },
    setup(){
        let route = useRoute();
        const dataContainer = reactive({
            loading:false,
            img:{
                img_1,
                img_2,
            },
            fit:'contain',
        }); 
        /** 
         * 缩放计算事件
         *  */
        function handleResizeScreen(rect){
            rect = rect || {};
            /** 
             * 计算缩放倍数 1920 * 1080
             * 根据设计图自己配置
             *  */
            let baseSize = 16;  //基础大小，相当于1rem = 16像素
            let scale = rect.width / 1920;
            let fontSize = Math.round(baseSize * scale*100)/100 + 'px';
            setRem(fontSize);
        }
        watch(route,()=>{
            let queryParams = route.query || {};
            let fitMap = {
                'cover':'cover',
                'contain':'contain',
            };
            dataContainer.fit = fitMap[queryParams.fit] || 'contain';
        },{
            immediate:true,
        });
        return {
            dataContainer,
            handleResizeScreen,
        };
    },
});
</script>

<template>
    <div class="big-screen-view">
        <AutoScalContainerV2
            :ratio="1920/1080"
            @onResizeScreen="handleResizeScreen"
            :fit="dataContainer.fit">
            <div 
                class="big-screen-view-container"
                :style="{
                    '--bg-img-1':`url(${dataContainer.img.img_1})`,
                    '--bg-img-2':`url(${dataContainer.img.img_2})`,
                }" >
                <div class="head">
                ...
                </div>
                <div class="content">
                    ...
                  
                </div>
            </div>
        </AutoScalContainerV2>
    </div>
</template>

<style lang="scss" scoped>
.big-screen-view{
    width: 100vw;
    height: 100vh;
    overflow: hidden;
    background-color: #031045c7;
    .big-screen-view-container{
        width: 100%;
        height: 100%;
        background-color: rgb(169, 169, 169);
        display: flex;
        flex-direction: column;
        background-image: var(--bg-img-1);
        background-repeat: no-repeat;
        background-size: 100% 100%;
        background-position: center;
     
        }
}
</style>

```
- vue2版本

``` vue
<template>
<div class="all-screen"> 
  <div class="auto-scal-container" ref="AutoScalContainerRef">
    <div ref="DomRef" class="auto-scal-container-inner">
      <slot></slot>
    </div>
  </div>
</div>
</template>

<script>
import { setRem } from "./setRem.js";
export default {
  props: {
    width: {
      type: Number,
      default: 1920,
    },
    height: {
      type: Number,
      default: 1080,
    },
    /** 内部容器的宽高比例 */
    ratio: {
      type: Number,
      default: 1920 / 1080,
    },
    fullScreen: {
      type: Boolean,
      default: false,
    },
  },
  data() {
    return {
      dataContainer: {
        height: this.height,
        width: this.width,
        ratio: this.ratio,
      },
      timer: null,
      timer_1: null,
    };
  },
  created() {
    if (!this.fullScreen) {
      this.timer = setInterval(() => {
        this.fnContainer();
      }, 300);
    }
  },
  mounted() {
    if (!this.fullScreen) {
      this.autoResizeScreen();
      window.addEventListener("resize", this.fnContainer);
    }
  },

  beforeDestroy() {
    window.removeEventListener("resize", this.fnContainer);
    window.clearInterval(this.timer);
  },
  methods: {
    isActive() {
      if (!this.$refs.DomRef) return false;
      return this.$refs.DomRef.getRootNode() === document;
    },
    fnContainer() {
      clearTimeout(this.timer);
      // timer_1 = setTimeout(()=>{
      this.autoResizeScreen();
      // },16);
    },
    autoResizeScreen() {
      if (!this.$refs.AutoScalContainerRef) return;
      if (!this.$refs.DomRef) return;
      if (!this.isActive()) return;
      let rect = this.$refs.AutoScalContainerRef.getBoundingClientRect();
      let clientWidth = rect.width;
      let clientHeight = rect.height;
      let width = this.dataContainer.width;
      let height = this.dataContainer.height;
      let domWidth = 0;
      let domHeight = 0;
      let domTop = 0;
      let domLeft = 0;

      /** 使用外部传入的比例或者传入的宽高计算比例 */
      let ratio = this.dataContainer.ratio || width / height;
      if (clientWidth / clientHeight > ratio) {
        domHeight = clientHeight;
        domWidth = ratio * domHeight;
        domTop = 0;
        domLeft = (clientWidth - domWidth) / 2;
      } else {
        domWidth = clientWidth;
        domHeight = domWidth / ratio;
        domTop = (clientHeight - domHeight) / 2;
        domLeft = 0;
      }

      // 防止组件销毁后还执行设置状态s
      Object.assign(this.$refs.DomRef.style, {
        width: `${domWidth}px`,
        height: `${domHeight}px`,
        top: `${domTop}px`,
        left: `${domLeft}px`,
      });
      let baseSize = 192; //基础大小，相当于1rem = 16像素
      let scale = domWidth / 1920;
      let fontSize = Math.round(baseSize * scale * 100) / 100 + "px";
      setRem(fontSize);
      this.$emit("onResizeScreen");
    },
  },
};
</script>

<style lang="scss" scoped>
.all-screen {
  width: 100vw;
  height: 100vh;
      background-color: #082d36;
}
.auto-scal-container {
  width: 100%;
  height: 100%;
  position: relative;
  display: flex;
  justify-content: flex-start;
  align-items: flex-start;
  overflow: auto;
  /** 隐藏滚动条 */
  -ms-overflow-style: none;
  scrollbar-width: none;
  background-color: #0e1b22;
  &::-webkit-scrollbar {
    display: none;
  }
  > .auto-scal-container-inner {
    position: absolute;
    overflow: hidden;
    transform-origin: left top;
    width: 0;
    height: 0;
    top: 0;
    left: 0;
  }
}
</style>

```
2. 利用transform,实现缩放 

2.1 使用v-scale-screen

``` 
npm install v-scale-screen
``` 

2.2
``` vue
<template>
    <div 
        class="auto-scal-container"
        ref="AutoScalContainerRef">
        <div 
            ref="DomRef" 
            class="auto-scal-container-inner">
            <slot></slot>
        </div>
    </div>
</template>

<script>
/** 
 * 自动缩放容器
 * 使用transform进行缩放
 *  */
import { 
    defineComponent,ref,getCurrentInstance,reactive,toRef, 
    computed,onMounted,onActivated,watch,
    onBeforeUnmount,
} from "vue";

export default defineComponent({
    props:{
        width:{
            type:Number,
            default:1920,
        },
        height:{
            type:Number,
            default:1080,
        },
        /** 内部容器的宽高比例 */
        ratio:{
            type:Number,
            default:1920 / 1080,
        },
        /** 
         * fit，原理同img的object-fit
         * contain : 被替换的内容将被缩放，以在填充元素的内容框时保持其宽高比。
         * cover : 被替换的内容在保持其宽高比的同时填充元素的整个内容框。如果对象的宽高比与内容框不相匹配，该对象将被剪裁以适应内容框。
         *  */
        fit:{
            type:String,
            default:'contain',
        },
    },
    emits:['onResizeScreen'],
    setup(props,{emit}){
        const DomRef = ref(null);  //组件实例
        const AutoScalContainerRef = ref(null);  //组件实例
        const dataContainer = reactive({
            height:toRef(props,'height'),
            width:toRef(props,'width'),
            ratio:toRef(props,'ratio'),
            fit:toRef(props,'fit'),
        });
        /** 是否是文档上 */
        function isActive(){
            if(!DomRef.value) return false;
            return DomRef.value.getRootNode() === document;
        }
        /** 自动缩放 */
        function autoResizeScreen(){
            if(!AutoScalContainerRef.value) return;
            if(!DomRef.value) return;
            if(!isActive) return;
            let rect = AutoScalContainerRef.value.getBoundingClientRect();
                let clientWidth = rect.width;
                let clientHeight = rect.height;
                var width = dataContainer.width;
                var height = dataContainer.height;
                let left = 0;
                let top = 0;
                let scale = 0;
                /** 使用外部传入的比例或者传入的宽高计算比例 */
                let ratio = dataContainer.ratio || (width / height);
            // 获取比例  可视化区域的宽高比与 屏幕的宽高比  来进行对应屏幕的缩放
            if(dataContainer.fit == 'contain'){
                if ((clientWidth / clientHeight) > ratio) {
                    scale = clientHeight / height;
                    top = 0;
                    left = (clientWidth - width * scale) / 2;
                } else {
                    scale = clientWidth / width;
                    left = 0;
                    top = (clientHeight - height * scale) / 2;
                }
            }
            if(dataContainer.fit == 'cover'){
                if ((clientWidth / clientHeight) > ratio) {
                    scale = clientWidth / width;
                } else {
                    scale = clientHeight / height;
                }
            }
            // 防止组件销毁后还执行设置状态s
            Object.assign(DomRef.value.style, {
                transform: `scale(${scale})`,
                left: `${left}px`,
                top: `${top}px`,
            });
            /** 向外部通知已经计算缩放 */
            emit('onResizeScreen');
        }
        /** 防抖 */
        let timer_1;
        function fnContainer(){
            clearTimeout(timer_1);
            // timer_1 = setTimeout(()=>{
                autoResizeScreen();
            // },16);
        }
        let timer = setInterval(()=>{
            fnContainer();
        },300);
        onMounted(() => {
            autoResizeScreen();
        });
        window.addEventListener('resize', fnContainer);
        onBeforeUnmount(() => {
            window.removeEventListener('resize', fnContainer);
            window.clearInterval(timer);
        });
        return {
            dataContainer,
            DomRef,
            AutoScalContainerRef,
        };
    },
});
</script>

<style lang="scss" scoped>
.auto-scal-container {
    width: 100%;
    height: 100%;
    position: relative;
    overflow: auto;
    /** 隐藏滚动条 */
    -ms-overflow-style: none;
    scrollbar-width: none;
    &::-webkit-scrollbar {
        display: none;
    }
    >.auto-scal-container-inner {
        overflow: hidden;
        transform-origin: left top;
        z-index: 999;
        width: max-content;
        height: max-content;
        position: absolute;
        top: 0;
        left: 0;
    }
}
</style>

```




